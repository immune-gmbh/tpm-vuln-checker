// MIT License
//
// Copyright (c) 2017, Jonathan Rudenberg
// Copyright (c) 2017, CRoCS, EnigmaBridge Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package cve201715361

import (
	"crypto/rsa"
	"fmt"
	"io"
	"math/big"

	"github.com/google/go-tpm/tpm2"
	"github.com/immune-gmbh/tpm-vuln-checker/pkg/tss"
)

type CVEData struct {
	Vulnerable bool
}

type test struct {
	Prime        *big.Int
	Fingerprints map[int64]struct{}
}

var tests = make([]test, 17)

func init() {
	bigOne := big.NewInt(1)
	n := &big.Int{}
	// relations table from https://github.com/crocs-muni/roca/pull/40
	for i, r := range [][2]int64{
		{2, 11}, {6, 13}, {8, 17}, {9, 19}, {3, 37}, {26, 53}, {20, 61},
		{35, 71}, {24, 73}, {13, 79}, {6, 97}, {51, 103}, {53, 107},
		{54, 109}, {42, 127}, {50, 151}, {78, 157},
	} {
		fps := make(map[int64]struct{})
		bp := big.NewInt(r[1])
		br := big.NewInt(r[0])
		for j := int64(0); j < r[1]; j++ {
			if n.Exp(big.NewInt(j), br, bp).Cmp(bigOne) == 0 {
				fps[j] = struct{}{}
			}
		}
		tests[i] = test{
			Prime:        big.NewInt(r[1]),
			Fingerprints: fps,
		}
	}
}

// IsWeak returns true if a RSA public key is vulnerable to Return of
// Coppersmith's Attack (ROCA).
func IsVulnerable(rwc io.ReadWriteCloser) (bool, *CVEData, error) {
	var cveData CVEData
	_ = tpm2.Startup(rwc, tpm2.StartupClear)
	session, _, err := tss.StartAuthSession(
		rwc,
		tpm2.HandleNull,
		tpm2.HandleNull,
		make([]byte, 16),
		nil,
		tpm2.SessionHMAC,
		tpm2.AlgXOR,
		tpm2.AlgSHA256)
	if err != nil {
		return false, nil, fmt.Errorf("couldn't start auth session")
	}
	defer tpm2.FlushContext(rwc, session)

	hnd, publicKey, err := tpm2.CreatePrimary(rwc, tpm2.HandleEndorsement, tpm2.PCRSelection{}, "", "", tss.RSAPublicKey)
	if err != nil {
		return false, nil, fmt.Errorf("couldn't creat rsa key for testing")
	}
	defer tpm2.FlushContext(rwc, hnd)
	tmp := &big.Int{}
	key := publicKey.(*rsa.PublicKey)
	for _, t := range tests {
		if _, ok := t.Fingerprints[tmp.Mod(key.N, t.Prime).Int64()]; !ok {
			cveData.Vulnerable = false
			return false, &cveData, nil
		}
	}
	cveData.Vulnerable = true
	return true, &cveData, nil
}
